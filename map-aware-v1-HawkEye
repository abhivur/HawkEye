#!/usr/bin/env python3
r"""
Simplified Single-Flight Drone Mission Planning System
Analyzes one flight's KML + JSON detection data to answer specific queries.

What this system CAN do with single-flight input:
- Generate corridor survey patterns around the actual flight path
- Recommend photo frequencies based on object density found in this flight
- Identify where objects were actually detected along the route
- Create optimized flight plans focused on areas where objects were found

What this system CANNOT do (requires historical data):
- Predict future detection probabilities
- Calculate "success rates" or "confidence scores"
- Make statistical predictions about areas not flown
"""

import os
import json
import logging
import numpy as np
import math
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum

# Import basic map extraction components
from map_extract import (
    FlightPlan, FlightPoint, FlightPlanParser, 
    haversine_distance, meters_to_degrees
)

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =============================================================================
# OUTPUT CONFIGURATION
# =============================================================================

HAWKEYE_OUTPUT_FOLDER = "hawkeye_output"

def ensure_hawkeye_output_directory():
    """Create hawkeye_output directory if it doesn't exist"""
    Path(HAWKEYE_OUTPUT_FOLDER).mkdir(exist_ok=True)
    logger.info(f"üìÅ Output directory ready: {HAWKEYE_OUTPUT_FOLDER}")

def get_hawkeye_output_path(filename: str) -> str:
    """Get full path for output file in hawkeye_output folder"""
    ensure_hawkeye_output_directory()
    return str(Path(HAWKEYE_OUTPUT_FOLDER) / filename)

# =============================================================================
# SIMPLIFIED DATA STRUCTURES
# =============================================================================

class QueryType(Enum):
    CORRIDOR_SURVEY = "corridor_survey"
    PHOTO_OPTIMIZATION = "photo_optimization" 
    OBJECT_LOCATION = "object_location"
    FLIGHT_OPTIMIZATION = "flight_optimization"

@dataclass
class DetectedObject:
    """Object from JSON detection results"""
    label: str
    confidence: float
    bbox: Dict[str, float]
    area: float

@dataclass
class FlightFrame:
    """Single frame with GPS location and detections"""
    frame_id: int
    timestamp: float
    gps_coords: Tuple[float, float, float]  # lat, lon, alt
    detected_objects: List[DetectedObject]

@dataclass
class ObjectLocation:
    """Where an object was actually found"""
    object_type: str
    gps_location: Tuple[float, float]
    frame_id: int
    confidence: float

@dataclass
class PhotoSegmentRecommendation:
    """Photo frequency recommendation for a flight segment"""
    segment_start: Tuple[float, float]
    segment_end: Tuple[float, float]
    distance_meters: float
    objects_found: int
    unique_object_types: int
    recommended_fps: float
    reasoning: str

@dataclass
class CorridorSurveyPlan:
    """Corridor survey pattern around original flight"""
    corridor_width_meters: float
    waypoints: List[FlightPoint]
    coverage_area_sqm: float
    flight_distance_meters: float

# =============================================================================
# SIMPLE QUERY PARSER
# =============================================================================

class SimpleQueryParser:
    """Parse user queries to understand what they're asking"""
    
    def parse_query(self, user_input: str) -> Tuple[QueryType, Dict[str, Any]]:
        """Parse user query and extract parameters"""
        user_input_lower = user_input.lower()
        
        # Extract corridor width if mentioned
        corridor_width = None
        if "around" in user_input_lower or "corridor" in user_input_lower:
            import re
            width_match = re.search(r'(\d+)\s*(?:meter|m\b|feet)', user_input_lower)
            if width_match:
                corridor_width = float(width_match.group(1))
                if "feet" in user_input_lower:
                    corridor_width = corridor_width * 0.3048  # Convert to meters
            
            return QueryType.CORRIDOR_SURVEY, {"corridor_width_meters": corridor_width or 10.0}
        
        # Photo frequency queries
        if any(word in user_input_lower for word in ["photo", "fps", "frame", "second", "picture"]):
            return QueryType.PHOTO_OPTIMIZATION, {}
        
        # Object location queries
        if any(word in user_input_lower for word in ["find", "where", "locate", "most"]):
            # Extract target objects
            target_objects = []
            object_keywords = ["person", "people", "vehicle", "car", "truck", "cone", "bench", "furniture"]
            for keyword in object_keywords:
                if keyword in user_input_lower:
                    target_objects.append(keyword)
            
            return QueryType.OBJECT_LOCATION, {"target_objects": target_objects}
        
        # Default to flight optimization
        return QueryType.FLIGHT_OPTIMIZATION, {}

# =============================================================================
# FLIGHT DATA PROCESSOR
# =============================================================================

class FlightDataProcessor:
    """Process single flight JSON data and map to GPS coordinates"""
    
    def load_flight_data(self, json_file_path: str, flight_plan: FlightPlan) -> List[FlightFrame]:
        """Load detection results and map to GPS coordinates along flight path"""
        
        # Load JSON data
        with open(json_file_path, 'r') as f:
            data = json.load(f)
        
        logger.info(f"üìÑ Loaded {len(data)} frames from JSON")
        
        # Convert to FlightFrame objects
        frames = []
        for frame_dict in data:
            detected_objects = []
            for obj_dict in frame_dict.get('detected_objects', []):
                detected_obj = DetectedObject(
                    label=obj_dict['label'],
                    confidence=obj_dict['confidence'],
                    bbox=obj_dict['bbox'],
                    area=obj_dict['area']
                )
                detected_objects.append(detected_obj)
            
            frame = FlightFrame(
                frame_id=frame_dict['frame_id'],
                timestamp=frame_dict['timestamp'],
                gps_coords=(0.0, 0.0, 0.0),  # Will be calculated
                detected_objects=detected_objects
            )
            frames.append(frame)
        
        # Map frames to GPS coordinates along flight path
        self._map_frames_to_flight_path(frames, flight_plan)
        
        logger.info(f"üìç Mapped {len(frames)} frames to GPS coordinates")
        return frames
    
    def _map_frames_to_flight_path(self, frames: List[FlightFrame], flight_plan: FlightPlan):
        """Map frame sequence to GPS coordinates along the flight path"""
        if not frames or len(flight_plan.points) < 2:
            return
        
        total_frames = len(frames)
        
        # Calculate cumulative distances along flight path
        cumulative_distances = [0.0]
        for i in range(1, len(flight_plan.points)):
            prev_point = flight_plan.points[i-1]
            curr_point = flight_plan.points[i]
            segment_distance = haversine_distance(
                prev_point.lat, prev_point.lon,
                curr_point.lat, curr_point.lon
            )
            cumulative_distances.append(cumulative_distances[-1] + segment_distance)
        
        total_distance = cumulative_distances[-1]
        
        # Map each frame to a GPS coordinate
        for i, frame in enumerate(frames):
            # Calculate progress through flight (0.0 to 1.0)
            progress = i / (total_frames - 1) if total_frames > 1 else 0.0
            
            # Convert progress to distance along path
            target_distance = progress * total_distance
            
            # Find GPS coordinates at this distance
            gps_coords = self._interpolate_gps_at_distance(
                target_distance, flight_plan.points, cumulative_distances
            )
            
            frame.gps_coords = gps_coords
    
    def _interpolate_gps_at_distance(self, target_distance: float, 
                                   waypoints: List[FlightPoint],
                                   cumulative_distances: List[float]) -> Tuple[float, float, float]:
        """Find GPS coordinates at specific distance along path"""
        
        if target_distance <= 0:
            wp = waypoints[0]
            return (wp.lat, wp.lon, wp.alt if wp.alt else 100.0)
        
        if target_distance >= cumulative_distances[-1]:
            wp = waypoints[-1]
            return (wp.lat, wp.lon, wp.alt if wp.alt else 100.0)
        
        # Find segment containing target distance
        for i in range(len(cumulative_distances) - 1):
            if cumulative_distances[i] <= target_distance <= cumulative_distances[i + 1]:
                segment_start_dist = cumulative_distances[i]
                segment_end_dist = cumulative_distances[i + 1]
                segment_length = segment_end_dist - segment_start_dist
                
                if segment_length > 0:
                    segment_progress = (target_distance - segment_start_dist) / segment_length
                else:
                    segment_progress = 0.0
                
                # Interpolate between waypoints
                wp1 = waypoints[i]
                wp2 = waypoints[i + 1]
                
                lat = wp1.lat + (wp2.lat - wp1.lat) * segment_progress
                lon = wp1.lon + (wp2.lon - wp1.lon) * segment_progress
                
                alt1 = wp1.alt if wp1.alt else 100
                alt2 = wp2.alt if wp2.alt else 100
                alt = alt1 + (alt2 - alt1) * segment_progress
                
                return (lat, lon, alt)
        
        # Fallback
        wp = waypoints[0]
        return (wp.lat, wp.lon, wp.alt if wp.alt else 100.0)

# =============================================================================
# MISSION ANALYZERS
# =============================================================================

class CorridorSurveyGenerator:
    """Generate corridor survey patterns around the actual flight path"""
    
    def generate_corridor_survey(self, original_plan: FlightPlan, 
                                corridor_width_meters: float = 10.0) -> CorridorSurveyPlan:
        """Generate systematic corridor survey around the flight path"""
        
        logger.info(f"üõ§Ô∏è  Generating {corridor_width_meters}m corridor survey")
        
        if len(original_plan.points) < 2:
            logger.warning("Need at least 2 waypoints for corridor survey")
            return CorridorSurveyPlan(corridor_width_meters, [], 0, 0)
        
        corridor_waypoints = []
        half_width = corridor_width_meters / 2
        total_distance = 0
        
        # Generate waypoints for each segment
        for i in range(len(original_plan.points) - 1):
            current_point = original_plan.points[i]
            next_point = original_plan.points[i + 1]
            
            # Calculate bearing between points
            bearing = self._calculate_bearing(current_point, next_point)
            
            # Calculate segment distance
            segment_distance = haversine_distance(
                current_point.lat, current_point.lon,
                next_point.lat, next_point.lon
            )
            total_distance += segment_distance
            
            # Generate corridor waypoints for this segment
            segment_waypoints = self._generate_segment_corridor(
                current_point, next_point, half_width, bearing, i
            )
            corridor_waypoints.extend(segment_waypoints)
        
        # Calculate coverage area
        coverage_area = corridor_width_meters * total_distance
        
        return CorridorSurveyPlan(
            corridor_width_meters=corridor_width_meters,
            waypoints=corridor_waypoints,
            coverage_area_sqm=coverage_area,
            flight_distance_meters=total_distance
        )
    
    def _calculate_bearing(self, point1: FlightPoint, point2: FlightPoint) -> float:
        """Calculate bearing between two points"""
        lat1, lon1 = math.radians(point1.lat), math.radians(point1.lon)
        lat2, lon2 = math.radians(point2.lat), math.radians(point2.lon)
        
        dlon = lon2 - lon1
        y = math.sin(dlon) * math.cos(lat2)
        x = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(dlon)
        
        bearing = math.atan2(y, x)
        return (math.degrees(bearing) + 360) % 360
    
    def _generate_segment_corridor(self, point1: FlightPoint, point2: FlightPoint,
                                 half_width_meters: float, bearing: float, 
                                 segment_index: int) -> List[FlightPoint]:
        """Generate corridor waypoints for one segment"""
        
        # Calculate perpendicular bearings (left and right of flight path)
        left_bearing = (bearing + 90) % 360
        right_bearing = (bearing - 90) % 360
        
        # Generate offset points
        left_start = self._offset_point(point1, left_bearing, half_width_meters)
        right_start = self._offset_point(point1, right_bearing, half_width_meters)
        left_end = self._offset_point(point2, left_bearing, half_width_meters)
        right_end = self._offset_point(point2, right_bearing, half_width_meters)
        
        # Create waypoints for systematic coverage
        waypoints = [
            FlightPoint(left_start[0], left_start[1], 100, f"corridor_L{segment_index}_start"),
            FlightPoint(left_end[0], left_end[1], 100, f"corridor_L{segment_index}_end"),
            FlightPoint(right_end[0], right_end[1], 100, f"corridor_R{segment_index}_end"),
            FlightPoint(right_start[0], right_start[1], 100, f"corridor_R{segment_index}_start"),
        ]
        
        return waypoints
    
    def _offset_point(self, point: FlightPoint, bearing: float, distance_meters: float) -> Tuple[float, float]:
        """Calculate new point offset by bearing and distance"""
        lat_offset, lon_offset = meters_to_degrees(distance_meters, point.lat)
        
        bearing_rad = math.radians(bearing)
        lat_delta = lat_offset * math.cos(bearing_rad)
        lon_delta = lon_offset * math.sin(bearing_rad)
        
        return (point.lat + lat_delta, point.lon + lon_delta)

class PhotoOptimizationAnalyzer:
    """Analyze object density to recommend photo frequencies"""
    
    def analyze_photo_requirements(self, frames: List[FlightFrame], 
                                 flight_plan: FlightPlan) -> List[PhotoSegmentRecommendation]:
        """Analyze where photos should be taken based on object density found"""
        
        logger.info(f"üì∏ Analyzing photo requirements for {len(frames)} frames")
        
        if len(flight_plan.points) < 2:
            return []
        
        recommendations = []
        
        # Analyze each flight segment
        for i in range(len(flight_plan.points) - 1):
            current_wp = flight_plan.points[i]
            next_wp = flight_plan.points[i + 1]
            
            # Find frames near this segment
            segment_frames = self._get_frames_near_segment(frames, current_wp, next_wp)
            
            # Analyze object density in this segment
            objects_found = sum(len(frame.detected_objects) for frame in segment_frames)
            unique_objects = len(set(obj.label for frame in segment_frames for obj in frame.detected_objects))
            
            # Calculate segment distance
            segment_distance = haversine_distance(
                current_wp.lat, current_wp.lon, next_wp.lat, next_wp.lon
            )
            
            # Recommend photo frequency based on what was actually found
            recommended_fps, reasoning = self._calculate_fps_recommendation(
                objects_found, unique_objects, len(segment_frames)
            )
            
            recommendation = PhotoSegmentRecommendation(
                segment_start=(current_wp.lat, current_wp.lon),
                segment_end=(next_wp.lat, next_wp.lon),
                distance_meters=segment_distance,
                objects_found=objects_found,
                unique_object_types=unique_objects,
                recommended_fps=recommended_fps,
                reasoning=reasoning
            )
            
            recommendations.append(recommendation)
        
        return recommendations
    
    def _get_frames_near_segment(self, frames: List[FlightFrame], 
                               point1: FlightPoint, point2: FlightPoint) -> List[FlightFrame]:
        """Find frames that were captured near this flight segment"""
        segment_frames = []
        
        for frame in frames:
            # Check if frame is close to either endpoint of segment
            dist1 = haversine_distance(point1.lat, point1.lon, frame.gps_coords[0], frame.gps_coords[1])
            dist2 = haversine_distance(point2.lat, point2.lon, frame.gps_coords[0], frame.gps_coords[1])
            
            # If frame is within 100m of either endpoint, consider it part of this segment
            if min(dist1, dist2) <= 100:
                segment_frames.append(frame)
        
        return segment_frames
    
    def _calculate_fps_recommendation(self, objects_found: int, unique_objects: int, 
                                    frames_analyzed: int) -> Tuple[float, str]:
        """Calculate photo frequency based on actual object density found"""
        
        if frames_analyzed == 0:
            return 1.0, "No data available for this segment"
        
        # Calculate object density per frame
        objects_per_frame = objects_found / frames_analyzed if frames_analyzed > 0 else 0
        
        # Recommend FPS based on actual findings
        if objects_per_frame >= 3 and unique_objects >= 3:
            return 6.0, f"High activity: {objects_found} objects ({unique_objects} types) found in {frames_analyzed} frames"
        elif objects_per_frame >= 1.5 and unique_objects >= 2:
            return 4.0, f"Moderate activity: {objects_found} objects ({unique_objects} types) found"
        elif objects_per_frame >= 0.5:
            return 2.0, f"Low activity: {objects_found} objects found in {frames_analyzed} frames"
        else:
            return 1.0, f"Minimal activity: {objects_found} objects found - conserve storage"

class ObjectLocationAnalyzer:
    """Analyze where specific objects were actually found"""
    
    def find_object_locations(self, frames: List[FlightFrame], 
                            target_objects: List[str]) -> List[ObjectLocation]:
        """Find where target objects were actually detected"""
        
        logger.info(f"üîç Searching for objects: {target_objects}")
        
        found_locations = []
        
        for frame in frames:
            for obj in frame.detected_objects:
                # Check if this object matches any target (flexible matching)
                if self._is_target_object(obj.label, target_objects):
                    location = ObjectLocation(
                        object_type=obj.label,
                        gps_location=(frame.gps_coords[0], frame.gps_coords[1]),
                        frame_id=frame.frame_id,
                        confidence=obj.confidence
                    )
                    found_locations.append(location)
        
        logger.info(f"üìç Found {len(found_locations)} target object locations")
        return found_locations
    
    def _is_target_object(self, detected_label: str, target_objects: List[str]) -> bool:
        """Check if detected object matches any target objects"""
        detected_lower = detected_label.lower()
        
        for target in target_objects:
            target_lower = target.lower()
            
            # Exact match
            if target_lower == detected_lower:
                return True
            
            # Partial match
            if target_lower in detected_lower or detected_lower in target_lower:
                return True
            
            # Semantic matching
            if self._semantic_match(target_lower, detected_lower):
                return True
        
        return False
    
    def _semantic_match(self, target: str, detected: str) -> bool:
        """Basic semantic matching for related objects"""
        semantic_groups = {
            "vehicle": ["car", "truck", "bus", "motorcycle", "van"],
            "person": ["human", "people", "pedestrian"],
            "furniture": ["chair", "table", "bench"],
        }
        
        # Check if target is a group name that includes detected object
        if target in semantic_groups and detected in semantic_groups[target]:
            return True
        
        # Check reverse
        for group_name, items in semantic_groups.items():
            if detected == group_name and target in items:
                return True
        
        return False

# =============================================================================
# MAIN MISSION ANALYZER
# =============================================================================

class SingleFlightMissionAnalyzer:
    """Main analyzer for single flight missions"""
    
    def __init__(self):
        self.query_parser = SimpleQueryParser()
        self.data_processor = FlightDataProcessor()
        self.corridor_generator = CorridorSurveyGenerator()
        self.photo_analyzer = PhotoOptimizationAnalyzer()
        self.object_analyzer = ObjectLocationAnalyzer()
    
    def analyze_mission(self, flight_plan_file: str, detection_json_file: str, 
                       user_query: str) -> Dict[str, Any]:
        """Analyze single flight mission based on user query"""
        
        logger.info(f"üöÅ Analyzing single flight mission")
        logger.info(f"‚ùì Query: {user_query}")
        
        # Parse the user query
        query_type, query_params = self.query_parser.parse_query(user_query)
        logger.info(f"üìã Query type: {query_type.value}")
        
        # Load flight plan and detection data
        flight_plan = FlightPlanParser.parse_file(flight_plan_file)
        frames = self.data_processor.load_flight_data(detection_json_file, flight_plan)
        
        # Generate basic flight statistics
        flight_stats = self._calculate_flight_statistics(flight_plan, frames)
        
        # Process based on query type
        result = {
            "query": user_query,
            "query_type": query_type.value,
            "flight_statistics": flight_stats,
            "analysis_results": {}
        }
        
        if query_type == QueryType.CORRIDOR_SURVEY:
            corridor_plan = self.corridor_generator.generate_corridor_survey(
                flight_plan, query_params.get("corridor_width_meters", 10.0)
            )
            result["analysis_results"] = self._format_corridor_results(corridor_plan)
            
        elif query_type == QueryType.PHOTO_OPTIMIZATION:
            photo_recommendations = self.photo_analyzer.analyze_photo_requirements(frames, flight_plan)
            result["analysis_results"] = self._format_photo_results(photo_recommendations)
            
        elif query_type == QueryType.OBJECT_LOCATION:
            target_objects = query_params.get("target_objects", [])
            object_locations = self.object_analyzer.find_object_locations(frames, target_objects)
            result["analysis_results"] = self._format_object_results(object_locations, target_objects)
            
        else:  # FLIGHT_OPTIMIZATION
            # Provide general analysis of the flight
            result["analysis_results"] = self._format_general_analysis(frames, flight_plan)
        
        # Save results
        self._save_results(result, flight_plan_file)
        
        return result
    
    def _calculate_flight_statistics(self, flight_plan: FlightPlan, 
                                   frames: List[FlightFrame]) -> Dict[str, Any]:
        """Calculate basic statistics about the flight"""
        
        # Flight plan statistics
        total_distance = 0
        if len(flight_plan.points) > 1:
            for i in range(len(flight_plan.points) - 1):
                total_distance += haversine_distance(
                    flight_plan.points[i].lat, flight_plan.points[i].lon,
                    flight_plan.points[i+1].lat, flight_plan.points[i+1].lon
                )
        
        # Detection statistics
        total_detections = sum(len(frame.detected_objects) for frame in frames)
        frames_with_detections = len([f for f in frames if f.detected_objects])
        
        # Object type statistics
        all_objects = [obj.label for frame in frames for obj in frame.detected_objects]
        unique_object_types = list(set(all_objects))
        object_counts = {obj_type: all_objects.count(obj_type) for obj_type in unique_object_types}
        
        return {
            "original_waypoints": len(flight_plan.points),
            "flight_distance_meters": total_distance,
            "total_frames": len(frames),
            "frames_with_detections": frames_with_detections,
            "total_objects_detected": total_detections,
            "unique_object_types": len(unique_object_types),
            "object_type_counts": object_counts
        }
    
    def _format_corridor_results(self, corridor_plan: CorridorSurveyPlan) -> Dict[str, Any]:
        """Format corridor survey results"""
        return {
            "corridor_width_meters": corridor_plan.corridor_width_meters,
            "survey_waypoints": len(corridor_plan.waypoints),
            "coverage_area_square_meters": corridor_plan.coverage_area_sqm,
            "total_survey_distance_meters": corridor_plan.flight_distance_meters,
            "waypoint_locations": [
                {"lat": wp.lat, "lon": wp.lon, "name": wp.name} 
                for wp in corridor_plan.waypoints
            ],
            "summary": f"Generated {len(corridor_plan.waypoints)} waypoints to survey {corridor_plan.corridor_width_meters}m corridor around original flight path"
        }
    
    def _format_photo_results(self, recommendations: List[PhotoSegmentRecommendation]) -> Dict[str, Any]:
        """Format photo optimization results"""
        
        total_photos_estimated = sum(
            rec.distance_meters / 5.0 * rec.recommended_fps  # Assume 5 m/s speed
            for rec in recommendations
        )
        
        avg_fps = np.mean([rec.recommended_fps for rec in recommendations]) if recommendations else 0
        
        return {
            "total_segments_analyzed": len(recommendations),
            "average_recommended_fps": avg_fps,
            "total_estimated_photos": int(total_photos_estimated),
            "segment_recommendations": [
                {
                    "segment": f"Segment {i+1}",
                    "start_location": {"lat": rec.segment_start[0], "lon": rec.segment_start[1]},
                    "end_location": {"lat": rec.segment_end[0], "lon": rec.segment_end[1]},
                    "distance_meters": rec.distance_meters,
                    "objects_found": rec.objects_found,
                    "unique_object_types": rec.unique_object_types,
                    "recommended_fps": rec.recommended_fps,
                    "reasoning": rec.reasoning
                }
                for i, rec in enumerate(recommendations)
            ],
            "summary": f"Analyzed {len(recommendations)} flight segments. Recommend variable photo rate averaging {avg_fps:.1f} fps based on object density found during flight."
        }
    
    def _format_object_results(self, locations: List[ObjectLocation], 
                             target_objects: List[str]) -> Dict[str, Any]:
        """Format object location results"""
        
        # Group by object type
        objects_by_type = {}
        for location in locations:
            if location.object_type not in objects_by_type:
                objects_by_type[location.object_type] = []
            objects_by_type[location.object_type].append(location)
        
        return {
            "target_objects_searched": target_objects,
            "total_locations_found": len(locations),
            "object_types_found": list(objects_by_type.keys()),
            "locations_by_type": {
                obj_type: [
                    {
                        "gps_location": {"lat": loc.gps_location[0], "lon": loc.gps_location[1]},
                        "frame_id": loc.frame_id,
                        "confidence": loc.confidence
                    }
                    for loc in locs
                ]
                for obj_type, locs in objects_by_type.items()
            },
            "summary": f"Found {len(locations)} instances of target objects across {len(set(loc.object_type for loc in locations))} different types."
        }
    
    def _format_general_analysis(self, frames: List[FlightFrame], 
                               flight_plan: FlightPlan) -> Dict[str, Any]:
        """Format general flight analysis"""
        
        # Find areas with highest object density
        high_activity_frames = [f for f in frames if len(f.detected_objects) >= 2]
        
        return {
            "flight_analysis": "General optimization analysis",
            "high_activity_locations": [
                {
                    "frame_id": frame.frame_id,
                    "gps_location": {"lat": frame.gps_coords[0], "lon": frame.gps_coords[1]},
                    "objects_detected": len(frame.detected_objects),
                    "object_types": [obj.label for obj in frame.detected_objects]
                }
                for frame in high_activity_frames[:10]  # Top 10
            ],
            "summary": f"Identified {len(high_activity_frames)} high-activity locations with 2+ objects detected."
        }
    
    def _save_results(self, results: Dict[str, Any], original_file: str):
        """Save analysis results"""
        
        # Save main results
        output_file = get_hawkeye_output_path(f"flight_analysis_{Path(original_file).stem}.json")
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)
        
        results["output_file"] = output_file
        logger.info(f"üìÑ Analysis saved to: {output_file}")
        
        # Generate KML file if corridor survey was requested
        if results["query_type"] == "corridor_survey":
            self._save_corridor_kml(results, original_file)

    def _save_corridor_kml(self, results: Dict[str, Any], original_file: str):
        """Save corridor survey as KML file"""
        
        kml_filename = f"corridor_survey_{Path(original_file).stem}.kml"
        kml_path = get_hawkeye_output_path(kml_filename)
        
        waypoints = results["analysis_results"]["waypoint_locations"]
        corridor_width = results["analysis_results"]["corridor_width_meters"]
        
        kml_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Corridor Survey - {corridor_width}m width</name>
    <description>Systematic survey pattern around original flight path</description>
    
    <Style id="corridorWaypointStyle">
      <IconStyle>
        <color>ff0080ff</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/orange-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="corridorPathStyle">
      <LineStyle>
        <color>7f0080ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
    <Folder>
      <name>Corridor Survey Waypoints</name>
'''
        
        # Add waypoints
        for wp in waypoints:
            kml_content += f'''      <Placemark>
        <name>{wp['name']}</name>
        <description>Corridor survey waypoint: {wp['lat']:.6f}, {wp['lon']:.6f}</description>
        <styleUrl>#corridorWaypointStyle</styleUrl>
        <Point>
          <coordinates>{wp['lon']},{wp['lat']},100</coordinates>
          <altitudeMode>relativeToGround</altitudeMode>
        </Point>
      </Placemark>
'''
        
        kml_content += '''    </Folder>
    
    <Placemark>
      <name>Corridor Survey Path</name>
      <description>Systematic coverage pattern</description>
      <styleUrl>#corridorPathStyle</styleUrl>
      <LineString>
        <extrude>1</extrude>
        <tessellate>1</tessellate>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>
'''
        
        # Add path coordinates
        for wp in waypoints:
            kml_content += f'          {wp["lon"]},{wp["lat"]},100\n'
        
        kml_content += '''        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>'''
        
        with open(kml_path, 'w') as f:
            f.write(kml_content)
        
        results["kml_file"] = kml_path
        logger.info(f"üó∫Ô∏è  Corridor survey KML saved: {kml_path}")

# =============================================================================
# MAIN INTERFACE
# =============================================================================

def main():
    """Main execution function for single-flight analysis"""
    print("üöÅ Enhanced Single-Flight Drone Mission Analysis System")
    print("=" * 70)
    print("üìä Analyzes: ONE KML flight + ONE JSON detection file + YOUR query")
    print("üéØ Provides actionable insights based on actual flight data")
    print()
    
    # File paths
    # casita-to-camp.kml is associated with drone_footage_frames and drone_footage_detection_results.json
    # panover.kml is associated with panover_frames and panover_detection_results.json
    # dsds.kml is associated with d_s_d_s_frames and d_s_d_s_detection_results.json

    flight_plan_file = "dsds.kml"
    if not flight_plan_file:
        flight_plan_file = "casita-to-camp.kml"  # Default for demo
    
    detection_json_file = "d_s_d_s_detection_results.json" #input("Enter path to JSON detection file: ").strip()
    if not detection_json_file:
        detection_json_file = "frame_detection_results.json"  # Default for demo
    
    # Check files exist
    if not Path(flight_plan_file).exists():
        print(f"‚ùå Flight plan not found: {flight_plan_file}")
        print("üí° Make sure the file path is correct and the file exists")
        return
    
    if not Path(detection_json_file).exists():
        print(f"‚ùå Detection data not found: {detection_json_file}")
        print("üí° Make sure the file path is correct and the file exists")
        return
    
    print(f"\n‚úÖ Files loaded successfully!")
    print(f"üìÅ Flight plan: {flight_plan_file}")
    print(f"üìÑ Detection data: {detection_json_file}")
    
    print("\nüí° What this system CAN answer with your single flight data:")
    print('  üõ§Ô∏è  "Survey the area 10 meters around this flight path"')
    print('  üì∏ "Should I take 8 photos every second along this route?"')
    print('  üìç "Where were vehicles actually found during this flight?"')
    print('  üîç "Where can I find the most people based on this flight?"')
    print('  üéØ "Generate an optimized flight plan based on detected objects"')
    print()
    
    # Get user query
    print("‚ùì Enter your mission query:")
    user_query = "Should I take 8 photos every second along this route?" #input("Query: ").strip()
    
    if not user_query:
        print("‚ùå No query provided. Please enter a specific question about your flight.")
        return
    
    print(f"\nüîÑ Processing query: '{user_query}'")
    print("‚è≥ Analyzing flight data and generating recommendations...")
    
    analyzer = SingleFlightMissionAnalyzer()
    
    try:
        results = analyzer.analyze_mission(
            flight_plan_file=flight_plan_file,
            detection_json_file=detection_json_file,
            user_query=user_query
        )
        
        # Display results based on query type
        print(f"\n{'='*70}")
        print("üìã MISSION ANALYSIS RESULTS")
        print('='*70)
        
        print(f"\nüéØ Your Query: {results['query']}")
        print(f"üìã Analysis Type: {results['query_type'].replace('_', ' ').title()}")
        
        # Flight statistics
        stats = results['flight_statistics']
        print(f"\nüìä Flight Data Summary:")
        print(f"   ‚Ä¢ Original waypoints: {stats['original_waypoints']}")
        print(f"   ‚Ä¢ Flight distance: {stats['flight_distance_meters']:.0f} meters")
        print(f"   ‚Ä¢ Total frames analyzed: {stats['total_frames']}")
        print(f"   ‚Ä¢ Frames with objects: {stats['frames_with_detections']}")
        print(f"   ‚Ä¢ Total objects detected: {stats['total_objects_detected']}")
        print(f"   ‚Ä¢ Unique object types: {stats['unique_object_types']}")
        
        if stats['object_type_counts']:
            top_objects = dict(list(stats['object_type_counts'].items())[:5])
            print(f"   ‚Ä¢ Top objects found: {top_objects}")
        
        # Analysis results
        analysis = results['analysis_results']
        print(f"\nüîç Analysis Results:")
        
        if results['query_type'] == 'corridor_survey':
            print(f"   üõ§Ô∏è  Corridor Width: {analysis['corridor_width_meters']}m")
            print(f"   üìç Survey Waypoints Generated: {analysis['survey_waypoints']}")
            print(f"   üìê Coverage Area: {analysis['coverage_area_square_meters']:.0f} square meters")
            print(f"   üìè Total Survey Distance: {analysis.get('total_survey_distance_meters', 0):.0f} meters")
            
            if 'kml_file' in results:
                print(f"   üìÑ KML File: {Path(results['kml_file']).name}")
                print(f"   üí° Load the KML file in Google Earth to visualize the corridor survey pattern")
                
        elif results['query_type'] == 'photo_optimization':
            print(f"   üì∏ Flight Segments Analyzed: {analysis['total_segments_analyzed']}")
            print(f"   üìä Average Recommended FPS: {analysis['average_recommended_fps']:.1f}")
            print(f"   üñºÔ∏è  Total Estimated Photos: {analysis['total_estimated_photos']}")
            
            print(f"\n   üì∏ Photo Recommendations by Segment:")
            for i, seg in enumerate(analysis['segment_recommendations'][:5], 1):
                print(f"      {i}. {seg['segment']}: {seg['recommended_fps']} fps")
                print(f"         Reason: {seg['reasoning']}")
                
        elif results['query_type'] == 'object_location':
            print(f"   üîç Objects Searched: {', '.join(analysis['target_objects_searched'])}")
            print(f"   üìç Total Locations Found: {analysis['total_locations_found']}")
            
            if analysis['object_types_found']:
                print(f"   üéØ Object Types Discovered: {', '.join(analysis['object_types_found'])}")
                
                print(f"\n   üìç Object Locations:")
                for obj_type, locations in analysis['locations_by_type'].items():
                    print(f"      ‚Ä¢ {obj_type}: {len(locations)} locations")
                    for loc in locations[:3]:  # Show first 3 locations
                        gps = loc['gps_location']
                        print(f"        - GPS: {gps['lat']:.6f}, {gps['lon']:.6f} (Frame {loc['frame_id']})")
            else:
                print(f"   ‚ùå No target objects found in the flight data")
                
        else:  # general analysis
            high_activity = analysis.get('high_activity_locations', [])
            print(f"   üî• High-Activity Locations: {len(high_activity)}")
            
            if high_activity:
                print(f"\n   üìç Top Activity Areas:")
                for i, loc in enumerate(high_activity[:5], 1):
                    gps = loc['gps_location']
                    print(f"      {i}. Frame {loc['frame_id']}: {loc['objects_detected']} objects")
                    print(f"         GPS: {gps['lat']:.6f}, {gps['lon']:.6f}")
                    print(f"         Objects: {', '.join(loc['object_types'])}")
        
        print(f"\nüìÑ Summary: {analysis['summary']}")
        
        # Output files
        print(f"\nüìÅ Generated Files:")
        print(f"   üìä Detailed Analysis: {Path(results['output_file']).name}")
        
        if 'kml_file' in results:
            print(f"   üó∫Ô∏è  KML Flight Plan: {Path(results['kml_file']).name}")
        
        print(f"\nüìÇ All files saved to: {HAWKEYE_OUTPUT_FOLDER}/")
        print(f"\n‚úÖ Analysis completed successfully!")
        
        # Actionable recommendations
        print(f"\nüí° ACTIONABLE INSIGHTS:")
        if results['query_type'] == 'corridor_survey':
            print(f"   ‚Ä¢ Use the generated {analysis['survey_waypoints']} waypoints for systematic area coverage")
            print(f"   ‚Ä¢ Load the KML file into your drone flight planning software")
            print(f"   ‚Ä¢ This pattern will cover {analysis['coverage_area_square_meters']:.0f} sq meters efficiently")
            
        elif results['query_type'] == 'photo_optimization':
            avg_fps = analysis['average_recommended_fps']
            if avg_fps > 5:
                print(f"   ‚Ä¢ High object density detected - use {avg_fps:.1f} fps for detailed capture")
            elif avg_fps > 3:
                print(f"   ‚Ä¢ Moderate activity - {avg_fps:.1f} fps provides good balance")
            else:
                print(f"   ‚Ä¢ Low activity area - {avg_fps:.1f} fps conserves storage while capturing key data")
            print(f"   ‚Ä¢ Estimated {analysis['total_estimated_photos']} photos for complete coverage")
            
        elif results['query_type'] == 'object_location':
            if analysis['total_locations_found'] > 0:
                print(f"   ‚Ä¢ {analysis['total_locations_found']} target objects found at specific GPS coordinates")
                print(f"   ‚Ä¢ Focus future flights on these high-value areas")
                print(f"   ‚Ä¢ Use GPS coordinates for ground team navigation")
            else:
                print(f"   ‚Ä¢ No target objects found - consider expanding search area or adjusting detection criteria")
                
        else:
            if len(analysis.get('high_activity_locations', [])) > 0:
                print(f"   ‚Ä¢ Focus on {len(analysis['high_activity_locations'])} high-activity areas for future missions")
                print(f"   ‚Ä¢ These locations had the most object detections during your flight")
        
    except Exception as e:
        print(f"\n‚ùå Analysis failed: {e}")
        logger.error(f"Analysis failed: {e}", exc_info=True)
        print("üí° Please check your input files and try again")

def interactive_demo():
    """Interactive demo that shows system capabilities"""
    print("üß™ Interactive Demo Mode")
    print("=" * 50)
    print("This demo shows what the system can do with sample data.")
    print()
    
    # Check for demo files
    demo_files = {
        "flight_plan": "casita-to-camp.kml",
        "detections": "frame_detection_results.json"
    }
    
    missing_files = []
    for file_type, filename in demo_files.items():
        if not Path(filename).exists():
            missing_files.append(filename)
    
    if missing_files:
        print("‚ùå Demo files not found:")
        for file in missing_files:
            print(f"   ‚Ä¢ {file}")
        print("\nüí° Make sure demo files are in the current directory to run the demo.")
        return
    
    print("‚úÖ Demo files found!")
    print(f"üìÅ Flight plan: {demo_files['flight_plan']}")
    print(f"üìÑ Detection data: {demo_files['detections']}")
    
    # Sample queries to demonstrate
    sample_queries = [
        "Survey the area 15 meters around this flight path",
        "Should I take 6 photos every second along this route?",
        "Where were people actually found during this flight?",
        "Find all vehicles detected in this flight"
    ]
    
    print("\nüìã Available demo queries:")
    for i, query in enumerate(sample_queries, 1):
        print(f"   {i}. {query}")
    
    print("\n‚ùì Choose a demo query (1-4) or enter your own:")
    user_input = input("Selection: ").strip() # <- This is the query / objective
    
    # Parse user selection
    if user_input.isdigit() and 1 <= int(user_input) <= len(sample_queries):
        selected_query = sample_queries[int(user_input) - 1]
    elif user_input:
        selected_query = user_input
    else:
        print("‚ùå No query selected. Exiting demo.")
        return
    
    print(f"\nüîÑ Running demo with query: '{selected_query}'")
    
    analyzer = SingleFlightMissionAnalyzer()
    
    try:
        results = analyzer.analyze_mission(
            flight_plan_file=demo_files['flight_plan'],
            detection_json_file=demo_files['detections'],
            user_query=selected_query
        )
        
        print("\nüéâ Demo completed successfully!")
        print(f"üìä Query Type: {results['query_type'].replace('_', ' ').title()}")
        print(f"üìÑ Analysis saved to: {Path(results['output_file']).name}")
        print(f"üìÅ Check the '{HAWKEYE_OUTPUT_FOLDER}' folder for detailed results")
        
    except Exception as e:
        print(f"‚ùå Demo failed: {e}")
        logger.error(f"Demo failed: {e}", exc_info=True)

def demo():
    """Demo function using provided sample data"""
    print("üß™ Running single-flight analysis demo...")
    
    flight_plan_file = "casita-to-camp.kml"
    detection_json_file = "frame_detection_results.json"
    
    if not Path(flight_plan_file).exists() or not Path(detection_json_file).exists():
        print("‚ùå Demo files not found. Make sure KML and JSON files are in current directory.")
        print("üí° Or run the main program to enter your own file paths.")
        return
    
    # Show available demo options
    print("üìã Demo options:")
    print("  1. Quick demo with corridor survey")
    print("  2. Interactive demo with query selection")
    
    choice = input("Enter choice (1 or 2): ").strip()
    
    if choice == "2":
        interactive_demo()
    else:
        # Quick demo with corridor survey
        analyzer = SingleFlightMissionAnalyzer()
        test_query = "Survey the area 12 meters around this flight path"
        
        try:
            results = analyzer.analyze_mission(
                flight_plan_file=flight_plan_file,
                detection_json_file=detection_json_file,
                user_query=test_query
            )
            
            print("üéâ Demo completed!")
            print(f"üìä Analyzed {results['flight_statistics']['total_frames']} frames")
            
            if results['query_type'] == 'corridor_survey':
                analysis = results['analysis_results']
                print(f"üõ§Ô∏è  Generated {analysis['survey_waypoints']} corridor waypoints")
                print(f"üìê Coverage area: {analysis['coverage_area_square_meters']:.0f} sq meters")
            
            print(f"üìÅ Files saved to: {HAWKEYE_OUTPUT_FOLDER}/")
            
        except Exception as e:
            print(f"‚ùå Demo failed: {e}")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--demo":
        demo()
    elif len(sys.argv) > 1 and sys.argv[1] == "--interactive":
        interactive_demo()
    else:
        main()
