#!/usr/bin/env python3
r"""
Input-Based Intelligent Drone Mission Planning System
Receives KML flight plan, JSON detection results, and user query to generate optimized flight plans.

Run with: python input_based_mission_planner.py
"""

import os
import json
import logging
import numpy as np
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum
from sklearn.cluster import KMeans

# Import enhanced map extraction components
from map_extract import (
    FlightPlan, FlightPoint, FlightPlanParser, 
    QGISMapGenerator, generate_flight_context_map,
    haversine_distance, meters_to_degrees, ensure_output_directory
)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# =============================================================================
# OUTPUT CONFIGURATION
# =============================================================================

# Centralized output folder
HAWKEYE_OUTPUT_FOLDER = "hawkeye_output"

def ensure_hawkeye_output_directory():
    """Create hawkeye_output directory if it doesn't exist"""
    Path(HAWKEYE_OUTPUT_FOLDER).mkdir(exist_ok=True)
    logger.info(f"ðŸ“ Output directory ready: {HAWKEYE_OUTPUT_FOLDER}")

def get_hawkeye_output_path(filename: str) -> str:
    """Get full path for output file in hawkeye_output folder"""
    ensure_hawkeye_output_directory()
    return str(Path(HAWKEYE_OUTPUT_FOLDER) / filename)

# =============================================================================
# DATA STRUCTURES
# =============================================================================

class MissionType(Enum):
    SEARCH = "search"
    SURVEY = "survey"
    INSPECTION = "inspection"
    MONITORING = "monitoring"

@dataclass
class MissionObjective:
    """Mission objective structure"""
    mission_type: MissionType
    target_objects: List[str]
    user_goal: str

@dataclass
class DetectedObject:
    """Object detection result from JSON input"""
    label: str
    confidence: float
    bbox: Dict[str, float]  # xmin, ymin, xmax, ymax
    area: float

@dataclass
class FrameData:
    """Frame data from JSON input"""
    frame_id: int
    timestamp: float
    frame_path: str
    gps_coords: Tuple[float, float, float]  # Will be calculated
    detected_objects: List[DetectedObject]

@dataclass
class SceneObservation:
    """Processed observation from frame data"""
    frame_id: int
    timestamp: float
    gps_coords: Tuple[float, float, float]
    detected_objects: List[str]
    scene_description: str
    relevance_score: float

@dataclass
class OptimizationSuggestion:
    """Flight plan optimization suggestion"""
    suggestion_type: str
    location: Optional[Tuple[float, float]]
    description: str
    reason: str

# =============================================================================
# MISSION OBJECTIVE PARSER
# =============================================================================

class SimpleMissionParser:
    """Parse user objectives into structured format"""
    
    def __init__(self):
        # Updated for various detection scenarios
        self.target_keywords = {
            "person": ["person", "people", "human", "student", "pedestrian", "staff", "faculty"],
            "vehicle": ["car", "truck", "vehicle", "suv", "motorcycle", "bus", "van"],
            "building": ["building", "structure", "house", "facility", "dorm", "classroom"],
            "furniture": ["bench", "chair", "table", "furniture"],
            "equipment": ["equipment", "machinery", "construction"],
            "umbrella": ["umbrella", "shade", "canopy"],
            "general": ["object", "item", "thing"]
        }
    
    def parse_objective(self, user_input: str) -> MissionObjective:
        """Parse natural language objective"""
        user_input_lower = user_input.lower()
        
        # Determine mission type
        if "find" in user_input_lower or "search" in user_input_lower or "locate" in user_input_lower:
            mission_type = MissionType.SEARCH
        elif "survey" in user_input_lower or "map" in user_input_lower or "count" in user_input_lower:
            mission_type = MissionType.SURVEY
        elif "inspect" in user_input_lower or "check" in user_input_lower or "monitor" in user_input_lower:
            mission_type = MissionType.INSPECTION
        else:
            mission_type = MissionType.MONITORING
        
        # Extract target objects
        target_objects = []
        for target, keywords in self.target_keywords.items():
            if any(keyword in user_input_lower for keyword in keywords):
                target_objects.append(target)
        
        return MissionObjective(
            mission_type=mission_type,
            target_objects=target_objects,
            user_goal=user_input
        )

# =============================================================================
# JSON DATA PROCESSOR
# =============================================================================

class JSONDataProcessor:
    """Process JSON detection results and map to GPS coordinates"""
    
    def __init__(self):
        pass
    
    def load_detection_results(self, json_file_path: str) -> List[FrameData]:
        """
        Load detection results from JSON file
        
        Args:
            json_file_path: Path to JSON file with detection results
            
        Returns:
            List of FrameData objects
        """
        with open(json_file_path, 'r') as f:
            data = json.load(f)
        
        frame_data_list = []
        
        for frame_dict in data:
            # Convert detected objects
            detected_objects = []
            for obj_dict in frame_dict.get('detected_objects', []):
                detected_obj = DetectedObject(
                    label=obj_dict['label'],
                    confidence=obj_dict['confidence'],
                    bbox=obj_dict['bbox'],
                    area=obj_dict['area']
                )
                detected_objects.append(detected_obj)
            
            # Create frame data (GPS coords will be calculated later)
            frame_data = FrameData(
                frame_id=frame_dict['frame_id'],
                timestamp=frame_dict['timestamp'],
                frame_path=frame_dict['frame_path'],
                gps_coords=(0.0, 0.0, 0.0),  # Will be calculated
                detected_objects=detected_objects
            )
            
            frame_data_list.append(frame_data)
        
        logger.info(f"âœ… Loaded {len(frame_data_list)} frames from JSON")
        return frame_data_list
    
    def map_frames_to_gps(self, frame_data_list: List[FrameData], 
                         flight_plan: FlightPlan) -> List[FrameData]:
        """
        Map frame data to GPS coordinates based on flight plan
        
        Args:
            frame_data_list: List of frame data
            flight_plan: Flight plan with GPS waypoints
            
        Returns:
            Updated frame data list with GPS coordinates
        """
        if not frame_data_list or not flight_plan.points:
            logger.warning("No frame data or flight plan waypoints available")
            return frame_data_list
        
        # Get total number of frames
        total_frames = len(frame_data_list)
        logger.info(f"ðŸ“ Mapping {total_frames} frames to {len(flight_plan.points)} waypoints")
        
        # Update each frame with GPS coordinates
        for i, frame_data in enumerate(frame_data_list):
            # Calculate progress through frames (0.0 to 1.0)
            progress = i / (total_frames - 1) if total_frames > 1 else 0.0
            
            # Estimate GPS coordinates
            gps_coords = self._estimate_gps_from_progress(progress, flight_plan)
            
            # Update frame data
            frame_data.gps_coords = gps_coords
            
            if i < 5:  # Log first few for verification
                logger.info(f"Frame {frame_data.frame_id}: GPS {gps_coords[0]:.6f}, {gps_coords[1]:.6f}")
        
        return frame_data_list
    
    def _estimate_gps_from_progress(self, progress: float, flight_plan: FlightPlan) -> Tuple[float, float, float]:
        """
        Estimate GPS coordinates based on progress through flight plan
        
        Args:
            progress: Progress through flight (0.0 to 1.0)
            flight_plan: Flight plan with waypoints
            
        Returns:
            Estimated (lat, lon, alt) tuple
        """
        waypoints = flight_plan.points
        
        if len(waypoints) == 0:
            return (0.0, 0.0, 100.0)
        elif len(waypoints) == 1:
            wp = waypoints[0]
            return (wp.lat, wp.lon, wp.alt if wp.alt else 100.0)
        
        # Calculate which segment we're in
        total_segments = len(waypoints) - 1
        segment_progress = progress * total_segments
        segment_index = int(segment_progress)
        segment_fraction = segment_progress - segment_index
        
        # Clamp to valid range
        segment_index = min(segment_index, total_segments - 1)
        
        # Interpolate between waypoints
        wp1 = waypoints[segment_index]
        wp2 = waypoints[segment_index + 1]
        
        lat = wp1.lat + (wp2.lat - wp1.lat) * segment_fraction
        lon = wp1.lon + (wp2.lon - wp1.lon) * segment_fraction
        
        # Handle altitude
        alt1 = wp1.alt if wp1.alt else 100
        alt2 = wp2.alt if wp2.alt else 100
        alt = alt1 + (alt2 - alt1) * segment_fraction
        
        return (lat, lon, alt)

# =============================================================================
# SCENE ANALYZER
# =============================================================================

class SceneAnalyzer:
    """Analyze scenes from frame data and generate observations"""
    
    def __init__(self):
        pass
    
    def process_frame_data(self, frame_data_list: List[FrameData], 
                          mission_objective: MissionObjective) -> List[SceneObservation]:
        """
        Process frame data into scene observations
        
        Args:
            frame_data_list: List of frame data with GPS coordinates
            mission_objective: Mission objective
            
        Returns:
            List of scene observations
        """
        observations = []
        
        for frame_data in frame_data_list:
            if not frame_data.detected_objects:
                continue
            
            # Extract object labels
            object_labels = [obj.label for obj in frame_data.detected_objects]
            
            # Generate scene description
            scene_description = self.generate_scene_description(frame_data.detected_objects, frame_data.frame_id)
            
            # Calculate relevance score
            relevance_score = self.calculate_relevance_score(object_labels, mission_objective)
            
            # Create observation
            observation = SceneObservation(
                frame_id=frame_data.frame_id,
                timestamp=frame_data.timestamp,
                gps_coords=frame_data.gps_coords,
                detected_objects=list(set(object_labels)),
                scene_description=scene_description,
                relevance_score=relevance_score
            )
            
            observations.append(observation)
        
        logger.info(f"âœ… Generated {len(observations)} scene observations")
        return observations
    
    def generate_scene_description(self, detected_objects: List[DetectedObject], frame_id: int) -> str:
        """Generate natural language description of the scene"""
        if not detected_objects:
            return "No objects detected in this frame"
        
        # Count object types
        object_counts = {}
        for obj in detected_objects:
            label = obj.label
            if label not in object_counts:
                object_counts[label] = 0
            object_counts[label] += 1
        
        # Build description
        descriptions = []
        for label, count in object_counts.items():
            if count == 1:
                descriptions.append(f"a {label}")
            else:
                descriptions.append(f"{count} {label}s")
        
        # Create natural sentence
        if len(descriptions) == 1:
            scene_desc = f"Frame {frame_id} shows {descriptions[0]}"
        elif len(descriptions) == 2:
            scene_desc = f"Frame {frame_id} shows {descriptions[0]} and {descriptions[1]}"
        else:
            scene_desc = f"Frame {frame_id} shows {', '.join(descriptions[:-1])}, and {descriptions[-1]}"
        
        return scene_desc
    
    def calculate_relevance_score(self, detected_objects: List[str], mission_objective: MissionObjective) -> float:
        """Calculate how relevant detected objects are to mission objective"""
        if not detected_objects or not mission_objective.target_objects:
            return 0.0
        
        # Simple keyword matching for relevance
        matches = 0
        total_targets = len(mission_objective.target_objects)
        
        for target in mission_objective.target_objects:
            target_lower = target.lower()
            for detected in detected_objects:
                detected_lower = detected.lower()
                # Check if target keywords match detected objects
                if target_lower in detected_lower or detected_lower in target_lower:
                    matches += 1
                    break
        
        return min(matches / total_targets, 1.0) if total_targets > 0 else 0.0

# =============================================================================
# FLIGHT PLAN OPTIMIZER
# =============================================================================

class FlightPlanOptimizer:
    """Optimize flight plans based on observations and objectives"""
    
    def __init__(self):
        pass
    
    def optimize_flight_plan(self, 
                           original_plan: FlightPlan,
                           observations: List[SceneObservation],
                           mission_objective: MissionObjective) -> Tuple[FlightPlan, List[OptimizationSuggestion]]:
        """
        Optimize flight plan based on observations and mission objective
        
        Returns:
            optimized_plan: New optimized flight plan
            suggestions: List of optimization suggestions
        """
        suggestions = []
        
        # Analyze observations for mission-relevant areas
        high_value_areas = []
        low_value_areas = []
        obstacles = []
        
        for obs in observations:
            # Check if observation is relevant to mission
            if any(target in obs.detected_objects for target in mission_objective.target_objects):
                high_value_areas.append(obs)
            elif obs.relevance_score < 0.3:
                low_value_areas.append(obs)
            
            # Check for obstacles (if any)
            if "wall" in obs.scene_description.lower() or "blocked" in obs.scene_description.lower():
                obstacles.append(obs)
        
        # Generate optimization suggestions
        if high_value_areas:
            # Suggest focusing on high-value areas
            for area in high_value_areas[:5]:  # Limit to top 5
                suggestions.append(OptimizationSuggestion(
                    suggestion_type="route",
                    location=(area.gps_coords[0], area.gps_coords[1]),
                    description=f"Add more waypoints around GPS {area.gps_coords[0]:.4f}, {area.gps_coords[1]:.4f}",
                    reason=f"High concentration of {', '.join(set(area.detected_objects))} detected"
                ))
        
        # Suggest optimizations based on object density
        self._suggest_density_optimizations(observations, suggestions, mission_objective)
        
        # Create optimized flight plan
        optimized_plan = self._create_optimized_plan(
            original_plan, high_value_areas, obstacles
        )
        
        return optimized_plan, suggestions
    
    def _suggest_density_optimizations(self, 
                                     observations: List[SceneObservation],
                                     suggestions: List[OptimizationSuggestion],
                                     mission_objective: MissionObjective):
        """Suggest optimizations based on object density"""
        
        # Group observations by area
        area_groups = {}
        for obs in observations:
            area_key = (round(obs.gps_coords[0], 4), round(obs.gps_coords[1], 4))
            if area_key not in area_groups:
                area_groups[area_key] = []
            area_groups[area_key].append(obs)
        
        # Find high-density target areas
        for area, obs_list in area_groups.items():
            if len(obs_list) >= 3:  # At least 3 frames in this area
                target_detections = 0
                for obs in obs_list:
                    if any(target in obs.detected_objects for target in mission_objective.target_objects):
                        target_detections += 1
                
                density_ratio = target_detections / len(obs_list)
                
                if density_ratio > 0.5:  # More than 50% have targets
                    suggestions.append(OptimizationSuggestion(
                        suggestion_type="high_density",
                        location=area,
                        description=f"Focus more time around GPS {area[0]:.4f}, {area[1]:.4f}",
                        reason=f"High target density: {target_detections}/{len(obs_list)} frames contain targets"
                    ))
                elif density_ratio == 0:  # No targets found
                    suggestions.append(OptimizationSuggestion(
                        suggestion_type="low_priority",
                        location=area,
                        description=f"Reduce coverage around GPS {area[0]:.4f}, {area[1]:.4f}",
                        reason=f"No targets found in {len(obs_list)} frames in this area"
                    ))
    
    def _create_optimized_plan(self,
                             original_plan: FlightPlan,
                             high_value_areas: List[SceneObservation],
                             obstacles: List[SceneObservation]) -> FlightPlan:
        """Create optimized flight plan"""
        optimized_points = []
        
        # Start with original points
        for point in original_plan.points:
            # Check if point is near an obstacle
            near_obstacle = False
            for obstacle in obstacles:
                distance = haversine_distance(
                    point.lat, point.lon,
                    obstacle.gps_coords[0], obstacle.gps_coords[1]
                )
                if distance < 100:  # 100 meters
                    near_obstacle = True
                    break
            
            if not near_obstacle:
                optimized_points.append(point)
        
        # Add extra waypoints near high-value areas
        for area in high_value_areas[:3]:  # Limit to top 3 areas
            center_lat, center_lon = area.gps_coords[0], area.gps_coords[1]
            
            # Calculate offset in meters and convert to degrees
            offset_meters = 50  # 50 meters
            lat_offset, lon_offset = meters_to_degrees(offset_meters, center_lat)
            
            # Add search pattern around high-value area
            for angle in [0, 90, 180, 270]:
                angle_rad = np.radians(angle)
                lat_delta = lat_offset * np.cos(angle_rad)
                lon_delta = lon_offset * np.sin(angle_rad)
                
                new_point = FlightPoint(
                    lat=center_lat + lat_delta,
                    lon=center_lon + lon_delta,
                    alt=100,
                    name=f"search_pattern_{angle}_frame{area.frame_id}"
                )
                optimized_points.append(new_point)
        
        return FlightPlan(
            points=optimized_points,
            name=f"{original_plan.name}_optimized",
            description=f"Optimized for: {', '.join(set([obj for area in high_value_areas for obj in area.detected_objects])) if high_value_areas else 'general surveillance'}"
        )
    
    def save_flight_plan_as_kml(self, flight_plan: FlightPlan, output_path: str):
        """Save flight plan as KML file"""
        kml_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>{flight_plan.name}</name>
    <description>{flight_plan.description}</description>
    <Style id="lineStyle">
      <LineStyle>
        <color>ff0000ff</color>
        <width>4</width>
      </LineStyle>
    </Style>
    <Style id="waypointStyle">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Folder>
      <name>Waypoints</name>
'''
        
        # Add waypoints as placemarks
        for i, point in enumerate(flight_plan.points):
            altitude = point.alt if point.alt else 100
            kml_content += f'''      <Placemark>
        <name>{point.name if point.name else f"WP{i+1}"}</name>
        <description>GPS: {point.lat:.6f}, {point.lon:.6f}</description>
        <styleUrl>#waypointStyle</styleUrl>
        <Point>
          <coordinates>{point.lon},{point.lat},{altitude}</coordinates>
          <altitudeMode>relativeToGround</altitudeMode>
        </Point>
      </Placemark>
'''
        
        kml_content += '''    </Folder>
    <Placemark>
      <name>Flight Path</name>
      <styleUrl>#lineStyle</styleUrl>
      <LineString>
        <extrude>1</extrude>
        <tessellate>1</tessellate>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>
'''
        
        # Add path coordinates
        for point in flight_plan.points:
            altitude = point.alt if point.alt else 100
            kml_content += f'          {point.lon},{point.lat},{altitude}\n'
        
        kml_content += '''        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>'''
        
        # Save to file
        ensure_output_directory()
        with open(output_path, 'w') as f:
            f.write(kml_content)
        
        logger.info(f"âœ… Saved optimized flight plan to: {output_path}")

    def save_flight_plan_as_png(self, flight_plan: FlightPlan, output_filename: str, 
                               detection_locations: List[Tuple[float, float, str]] = None):
        """Save flight plan as PNG map image in hawkeye_output folder"""
        output_path = get_hawkeye_output_path(output_filename)
        
        try:
            from map_extract import QGISMapGenerator
            
            # Create temporary KML for map generation
            temp_kml_path = output_path.replace('.png', '_temp.kml')
            
            # Generate KML content
            kml_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>{flight_plan.name}</name>
    <description>{flight_plan.description}</description>
    <Style id="optimizedPathStyle">
      <LineStyle>
        <color>ff00ff00</color>
        <width>6</width>
      </LineStyle>
    </Style>
    <Style id="optimizedWaypointStyle">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="detectionStyle">
      <IconStyle>
        <color>ffff0000</color>
        <scale>1.5</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/red-star.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Folder>
      <name>Optimized Waypoints</name>
'''
            
            # Add waypoints
            for i, point in enumerate(flight_plan.points):
                altitude = point.alt if point.alt else 100
                kml_content += f'''      <Placemark>
        <name>{point.name if point.name else f"OPT-WP{i+1}"}</name>
        <description>Optimized waypoint: {point.lat:.6f}, {point.lon:.6f}</description>
        <styleUrl>#optimizedWaypointStyle</styleUrl>
        <Point>
          <coordinates>{point.lon},{point.lat},{altitude}</coordinates>
          <altitudeMode>relativeToGround</altitudeMode>
        </Point>
      </Placemark>
'''
            
            kml_content += '''    </Folder>'''
            
            # Add detection locations if provided
            if detection_locations:
                kml_content += '''
    <Folder>
      <name>Target Detections</name>
'''
                for i, (lat, lon, obj_type) in enumerate(detection_locations):
                    kml_content += f'''      <Placemark>
        <name>TARGET: {obj_type}</name>
        <description>Found: {obj_type} at {lat:.6f}, {lon:.6f}</description>
        <styleUrl>#detectionStyle</styleUrl>
        <Point>
          <coordinates>{lon},{lat},100</coordinates>
          <altitudeMode>relativeToGround</altitudeMode>
        </Point>
      </Placemark>
'''
                kml_content += '''    </Folder>'''
            
            # Add flight path
            kml_content += '''
    <Placemark>
      <name>Optimized Flight Path</name>
      <styleUrl>#optimizedPathStyle</styleUrl>
      <LineString>
        <extrude>1</extrude>
        <tessellate>1</tessellate>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>
'''
            
            for point in flight_plan.points:
                altitude = point.alt if point.alt else 100
                kml_content += f'          {point.lon},{point.lat},{altitude}\n'
            
            kml_content += '''        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>'''
            
            # Save temporary KML
            with open(temp_kml_path, 'w') as f:
                f.write(kml_content)
            
            # Generate PNG map from KML
            map_generator = QGISMapGenerator()
            try:
                # Create flight plan object for map generation
                temp_plan = FlightPlan(
                    points=flight_plan.points,
                    name=f"{flight_plan.name}_optimized_visual",
                    description=flight_plan.description
                )
                
                # Generate map - override output to hawkeye_output folder
                png_path = map_generator.generate_contextual_map(
                    temp_plan, 
                    output_filename=Path(output_path).name
                )
                
                # Move the generated map to hawkeye_output if it's not already there
                if not png_path.startswith(HAWKEYE_OUTPUT_FOLDER):
                    import shutil
                    dest_path = get_hawkeye_output_path(Path(png_path).name)
                    if Path(png_path).exists():
                        shutil.move(png_path, dest_path)
                        png_path = dest_path
                
                logger.info(f"âœ… Saved optimized flight plan as PNG: {png_path}")
                
                # Clean up temporary KML
                try:
                    os.remove(temp_kml_path)
                except:
                    pass
                
                return png_path
                
            finally:
                map_generator.cleanup()
                
        except Exception as e:
            logger.error(f"Error generating PNG flight plan: {e}")
            # Fallback to KML if PNG generation fails
            kml_path = output_path.replace('.png', '.kml')
            with open(kml_path, 'w') as f:
                f.write(kml_content)
            logger.info(f"âœ… Fallback: Saved as KML instead: {kml_path}")
            return kml_path

# =============================================================================
# MISSION COORDINATOR
# =============================================================================

class InputBasedMissionCoordinator:
    """Coordinate mission planning using input files"""
    
    def __init__(self):
        self.parser = SimpleMissionParser()
        self.data_processor = JSONDataProcessor()
        self.scene_analyzer = SceneAnalyzer()
        self.optimizer = FlightPlanOptimizer()
        self.logger = logging.getLogger(__name__)
    
    def plan_mission_from_inputs(self, 
                                flight_plan_file: str,
                                detection_json_file: str,
                                user_objective: str) -> Dict[str, Any]:
        """
        Main mission planning function using input files
        
        Args:
            flight_plan_file: Path to KML flight plan file
            detection_json_file: Path to JSON detection results
            user_objective: User's mission objective
            
        Returns:
            Comprehensive mission plan with observations and suggestions
        """
        self.logger.info(f"ðŸš Starting input-based mission planning")
        self.logger.info(f"ðŸ“‹ Objective: {user_objective}")
        
        # Parse objective
        mission_objective = self.parser.parse_objective(user_objective)
        self.logger.info(f"ðŸŽ¯ Mission type: {mission_objective.mission_type.value}")
        self.logger.info(f"ðŸ” Target objects: {mission_objective.target_objects}")
        
        # Load flight plan
        original_plan = FlightPlanParser.parse_file(flight_plan_file)
        self.logger.info(f"ðŸ“ Loaded flight plan with {len(original_plan.points)} waypoints")
        
        # Load detection results
        frame_data_list = self.data_processor.load_detection_results(detection_json_file)
        
        # Map frames to GPS coordinates
        frame_data_list = self.data_processor.map_frames_to_gps(frame_data_list, original_plan)
        
        # Process frame data into observations
        observations = self.scene_analyzer.process_frame_data(frame_data_list, mission_objective)
        
        # Optimize flight plan
        optimized_plan, suggestions = self.optimizer.optimize_flight_plan(
            original_plan, observations, mission_objective
        )
        
        # Generate report
        report = self._generate_report(
            mission_objective, original_plan, optimized_plan,
            observations, suggestions, frame_data_list
        )
        
        # Save optimized flight plan as PNG map
        optimized_png_path = f"optimized_{Path(flight_plan_file).stem}_flight_plan.png"
        
        # Extract target detection locations for visualization
        target_detections = []
        for obs in observations:
            if obs.relevance_score > 0.7:  # High relevance observations
                for obj in obs.detected_objects:
                    if obj in mission_objective.target_objects:
                        target_detections.append((obs.gps_coords[0], obs.gps_coords[1], obj))
        
        png_path = self.optimizer.save_flight_plan_as_png(
            optimized_plan, 
            optimized_png_path,
            detection_locations=target_detections
        )
        report['optimized_flight_plan_file'] = png_path
        
        # Generate context map
        try:
            map_path = generate_flight_context_map(
                flight_plan_file,
                output_filename=f"{original_plan.name}_context_map.png",
                show_coordinates=False,
                export_coordinates=True
            )
            report['context_map_file'] = map_path
            self.logger.info(f"ðŸ—ºï¸  Generated context map: {map_path}")
        except Exception as e:
            self.logger.warning(f"Could not generate context map: {e}")
        
        self.logger.info("âœ… Mission planning complete!")
        
        return report
    
    def _generate_report(self,
                        mission_objective: MissionObjective,
                        original_plan: FlightPlan,
                        optimized_plan: FlightPlan,
                        observations: List[SceneObservation],
                        suggestions: List[OptimizationSuggestion],
                        frame_data_list: List[FrameData]) -> Dict[str, Any]:
        """Generate comprehensive mission report"""
        
        # Format observations for output
        formatted_observations = []
        for obs in observations:
            formatted_observations.append({
                "frame_id": obs.frame_id,
                "timestamp": obs.timestamp,
                "gps_location": {
                    "latitude": obs.gps_coords[0],
                    "longitude": obs.gps_coords[1],
                    "altitude": obs.gps_coords[2]
                },
                "detected_objects": obs.detected_objects,
                "description": obs.scene_description,
                "relevance_to_mission": obs.relevance_score
            })
        
        # Format suggestions
        formatted_suggestions = []
        for sugg in suggestions:
            formatted_suggestions.append({
                "type": sugg.suggestion_type,
                "location": {
                    "latitude": sugg.location[0] if sugg.location else None,
                    "longitude": sugg.location[1] if sugg.location else None
                },
                "suggestion": sugg.description,
                "reasoning": sugg.reason
            })
        
        # Key findings summary
        key_findings = []
        
        # Find target objects
        target_found_locations = []
        for obs in observations:
            if any(target in obs.detected_objects for target in mission_objective.target_objects):
                target_found_locations.append(obs)
                key_findings.append(
                    f"âœ… {', '.join([t for t in mission_objective.target_objects if t in obs.detected_objects])} "
                    f"found at GPS {obs.gps_coords[0]:.6f}, {obs.gps_coords[1]:.6f} (Frame {obs.frame_id})"
                )
        
        # Object statistics
        all_detected_objects = {}
        for obs in observations:
            for obj in obs.detected_objects:
                if obj not in all_detected_objects:
                    all_detected_objects[obj] = 0
                all_detected_objects[obj] += 1
        
        if all_detected_objects:
            key_findings.append(f"ðŸ“Š Objects detected: {', '.join([f'{obj} ({count}x)' for obj, count in sorted(all_detected_objects.items(), key=lambda x: x[1], reverse=True)])}")
        
        # Flight plan summary
        center_lat, center_lon = original_plan.get_center_point()
        area_height, area_width = original_plan.get_area_size_meters()
        
        return {
            "mission_objective": {
                "user_goal": mission_objective.user_goal,
                "mission_type": mission_objective.mission_type.value,
                "target_objects": mission_objective.target_objects
            },
            "input_data": {
                "total_frames_processed": len(frame_data_list),
                "frames_with_detections": len([f for f in frame_data_list if f.detected_objects]),
                "total_detections": sum(len(f.detected_objects) for f in frame_data_list)
            },
            "flight_plans": {
                "original_waypoints": len(original_plan.points),
                "optimized_waypoints": len(optimized_plan.points),
                "optimization_applied": len(optimized_plan.points) != len(original_plan.points),
                "center_coordinates": f"{center_lat:.6f}, {center_lon:.6f}",
                "area_size_meters": f"{area_width:.1f}m Ã— {area_height:.1f}m"
            },
            "key_findings": key_findings,
            "scene_observations": formatted_observations,
            "optimization_suggestions": formatted_suggestions,
            "summary": {
                "total_observations": len(observations),
                "high_relevance_scenes": len([o for o in observations if o.relevance_score > 0.7]),
                "target_objects_found": len(target_found_locations) > 0,
                "suggested_optimizations": len(suggestions)
            }
        }

# =============================================================================
# MAIN INTERFACE
# =============================================================================

def main():
    """Main execution function"""
    print("ðŸš Input-Based Drone Mission Planning System")
    print("=" * 60)
    print("ðŸ“Š Processes: KML flight plan + JSON detection results + User query")
    print("ðŸ“¤ Outputs: Optimized flight plan + Mission report")
    print()
    
    # Get user inputs
    flight_plan_file = "C:/Users/lukev/Projects/HawkEye/casita-to-camp.kml"
    if not Path(flight_plan_file).exists():
        print(f"âŒ File not found: {flight_plan_file}")
        return
    
    detection_json_file = "C:/Users/lukev/Projects/HawkEye/frame_detection_results.json"
    if not Path(detection_json_file).exists():
        print(f"âŒ File not found: {detection_json_file}")
        return
    
    print("\nðŸ’¡ Example objectives:")
    print('  - "Find vehicles in the area"')
    print('  - "Survey for people and benches"')
    print('  - "Locate cars and trucks"')
    print('  - "Monitor furniture placement"')
    print('  - "Search for any objects of interest"')
    
    user_objective = "Where can I most likely find the most people?"
    
    # Run mission planning
    coordinator = InputBasedMissionCoordinator()
    
    try:
        report = coordinator.plan_mission_from_inputs(
            flight_plan_file=flight_plan_file,
            detection_json_file=detection_json_file,
            user_objective=user_objective
        )
        
        # Display results
        print("\n" + "="*60)
        print("ðŸ“‹ MISSION PLANNING REPORT")
        print("="*60)
        
        print(f"\nðŸŽ¯ Mission: {report['mission_objective']['user_goal']}")
        print(f"ðŸ“ Type: {report['mission_objective']['mission_type']}")
        print(f"ðŸ” Targets: {', '.join(report['mission_objective']['target_objects'])}")
        
        # Input data summary
        input_data = report['input_data']
        print(f"\nðŸ“Š Input Data Summary:")
        print(f"   Total frames processed: {input_data['total_frames_processed']}")
        print(f"   Frames with detections: {input_data['frames_with_detections']}")
        print(f"   Total detections: {input_data['total_detections']}")
        
        # Flight plan info
        flight_info = report['flight_plans']
        print(f"\nðŸ—ºï¸  Flight Area Information:")
        print(f"   Center: {flight_info['center_coordinates']}")
        print(f"   Area Size: {flight_info['area_size_meters']}")
        print(f"   Original Waypoints: {flight_info['original_waypoints']}")
        print(f"   Optimized Waypoints: {flight_info['optimized_waypoints']}")
        print(f"   Optimization Applied: {'Yes' if flight_info['optimization_applied'] else 'No'}")
        
        print("\nðŸ”‘ KEY FINDINGS:")
        if report['key_findings']:
            for finding in report['key_findings']:
                print(f"  {finding}")
        else:
            print("  No specific targets detected in the processed frames")
        
        print("\nðŸ“Š SUMMARY:")
        summary = report['summary']
        print(f"  Scene observations: {summary['total_observations']}")
        print(f"  High relevance scenes: {summary['high_relevance_scenes']}")
        print(f"  Target objects found: {'Yes' if summary['target_objects_found'] else 'No'}")
        print(f"  Optimization suggestions: {summary['suggested_optimizations']}")
        
        if report['optimization_suggestions']:
            print("\nðŸ’¡ OPTIMIZATION SUGGESTIONS:")
            for i, sugg in enumerate(report['optimization_suggestions'][:5], 1):
                print(f"\n  {i}. {sugg['suggestion']}")
                print(f"     Reason: {sugg['reasoning']}")
                if sugg['location']['latitude']:
                    print(f"     Location: {sugg['location']['latitude']:.6f}, {sugg['location']['longitude']:.6f}")
        
        # Show some example observations
        if report['scene_observations']:
            print(f"\nðŸ“¸ Sample Observations (showing first 5):")
            for i, obs in enumerate(report['scene_observations'][:5], 1):
                print(f"\n  {i}. {obs['description']}")
                print(f"     GPS: {obs['gps_location']['latitude']:.6f}, {obs['gps_location']['longitude']:.6f}")
                print(f"     Relevance: {obs['relevance_to_mission']:.2f}")
        
        # Save detailed report to hawkeye_output
        output_file = get_hawkeye_output_path(f"mission_report_{Path(flight_plan_file).stem}.json")
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        print(f"\nðŸ“„ Detailed report saved to: {output_file}")
        
        # Show generated files
        if 'optimized_flight_plan_file' in report:
            print(f"âœ… Optimized flight plan saved to: {report['optimized_flight_plan_file']}")
            print(f"   Visual PNG map showing optimized route and target locations!")
        
        if 'context_map_file' in report:
            print(f"ðŸ—ºï¸  Context map saved to: {report['context_map_file']}")
            print(f"   Visual map showing flight area and surrounding geography")
        
        print(f"\nðŸŽ‰ Mission planning complete!")
        print(f"ðŸ“ All output files saved to: {HAWKEYE_OUTPUT_FOLDER}/")
        print(f"   Check the folder for your optimized flight plan and detailed analysis.")
        
    except Exception as e:
        print(f"\nâŒ Error: {e}")
        logger.error(f"Mission planning failed: {e}", exc_info=True)

def demo_with_provided_data():
    """Demo function using the provided sample data"""
    print("ðŸ§ª Running demo with provided sample data...")
    
    # Use the provided files from your uploads
    flight_plan_file = "casita-to-camp.kml"  # Your KML file
    detection_json_file = "frame_detection_results.json"  # Your JSON detection results
    user_objective = "Find vehicles in the area"  # Example objective based on your data
    
    # Check if files exist
    if not Path(flight_plan_file).exists():
        print(f"âŒ Demo file not found: {flight_plan_file}")
        print("ðŸ’¡ Make sure the KML file is in the current directory")
        return
    
    if not Path(detection_json_file).exists():
        print(f"âŒ Demo file not found: {detection_json_file}")
        print("ðŸ’¡ Make sure the JSON file is in the current directory")
        return
    
    print(f"ðŸ“ Using flight plan: {flight_plan_file}")
    print(f"ðŸ“„ Using detection data: {detection_json_file}")
    print(f"ðŸŽ¯ Mission: {user_objective}")
    print()
    
    # Run mission planning
    coordinator = InputBasedMissionCoordinator()
    
    try:
        report = coordinator.plan_mission_from_inputs(
            flight_plan_file=flight_plan_file,
            detection_json_file=detection_json_file,
            user_objective=user_objective
        )
        
        print("ðŸŽ‰ Demo completed successfully!")
        print(f"ðŸ“„ Report saved to: {report.get('optimized_flight_plan_file', 'N/A')}")
        
        # Quick summary
        summary = report['summary']
        print(f"\nðŸ“Š Quick Summary:")
        print(f"   - Processed {report['input_data']['total_frames_processed']} frames")
        print(f"   - Found {summary['total_observations']} relevant observations")
        print(f"   - Generated {summary['suggested_optimizations']} optimization suggestions")
        print(f"   - Target objects found: {'Yes' if summary['target_objects_found'] else 'No'}")
        print(f"\nðŸ“ All files saved to: {HAWKEYE_OUTPUT_FOLDER}/")
        
    except Exception as e:
        print(f"âŒ Demo failed: {e}")
        logger.error(f"Demo failed: {e}", exc_info=True)

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--demo":
        demo_with_provided_data()
    else:
        main()
